{"version":3,"sources":["components/universal/animated_p.js","components/lyrics/syncing/lyrics_sync_creator.js"],"names":["text","fadeOut","style","useState","opacity","setOpacity","displayText","setDisplayText","sleep","ms","Promise","resolve","setTimeout","useEffect","a","blurInAndOut","textAlign","transition","PROCESSED_LYRICS","gql","LyricsSyncCreator","startTime","endTime","useParams","youtubeID","geniusID","playerRef","useRef","playing","setPlaying","ended","setEnded","buffering","setBuffering","row","col","position","setPosition","syncedLyrics","setSyncedLyrics","detectKey","event","keyCode","length","map","line","rowIndex","word","colIndex","time","current","getCurrentTime","console","log","seekTo","window","addEventListener","removeEventListener","interval","setInterval","clearInterval","instructions","setInstructions","data","useQuery","variables","id","onCompleted","processedLyrics","__typename","Container","fluid","paddingLeft","paddingRight","centerContent","fontSize","color","zIndex","Row","className","ref","url","onEnded","onBuffer","onBufferEnd","controls","slice","minWidth","key","backgroundColor","marginBottom","marginLeft","centered"],"mappings":"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","file":"static/js/12.f3fb3354.chunk.js","sourcesContent":["import React, {useState, useEffect} from 'react';\nexport default function ({text, fadeOut, style}) {\n  const [opacity, setOpacity] = useState(0)\n  const [displayText, setDisplayText] = useState('')\n  const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));\n\n  useEffect(() => {\n    setOpacity(1)\n    setDisplayText(text)\n  }, [text])\n\n\n  //whenever the text changes fade in and out\n  useEffect(() => {\n    const blurInAndOut = async () => {\n      setOpacity(0)\n      await sleep(250)\n      setDisplayText(text)\n      setOpacity(1)\n    }\n    blurInAndOut()\n  }, [text])\n  return (\n    <p style={{textAlign: !fadeOut ? 'center' : 'left'   , transition: `opacity 0.25s`, opacity: opacity, ...style}}>\n      {displayText}\n    </p>\n  )\n}\n","import React, { useState, useEffect, useRef, useCallback } from 'react';\nimport { useParams } from 'react-router-dom';\nimport { useQuery, gql } from '@apollo/client';\nimport Row from 'react-bootstrap/Row';\nimport Container from 'react-bootstrap/Container';\nimport Loading from 'components/universal/loading';\nimport AnimatedP from 'components/universal/animated_p';\nimport CustomNavbar from 'components/universal/custom_navbar';\nimport LyricsSyncPreview from 'components/lyrics/preview/preview';\nimport ReactPlayer from 'react-player';\n\nconst PROCESSED_LYRICS = gql`\n  query processedlyrics($id: String) {\n    processedLyrics(id: $id) {\n      id\n      text\n    }\n  }\n`;\n\nexport default function LyricsSyncCreator({ startTime, endTime }) {\n  const { youtubeID, geniusID } = useParams();\n\n  const playerRef = useRef(null);\n\n  //denotes the epoch time when the video started playing. used to calculate the time when a key was pressed.\n  const [playing, setPlaying] = useState(false);\n\n  //called by the video player when the video has finished playing. used to conditionally render the preview\n  const [ended, setEnded] = useState(false);\n\n  //used to tell Video Player to start playing the song\n  const [buffering, setBuffering] = useState(true);\n\n  const [position, setPosition] = useState({ row: 0, col: 0 });\n\n  //these store the words and meta data of each lyrics (such as ID) and whenever a key is pressed store the lyric at that ID\n  const [syncedLyrics, setSyncedLyrics] = useState({});\n\n  useEffect(() => {\n    const syncWord = () => {\n      setPosition(({ row, col }) => {\n        if (row < syncedLyrics.length) {\n          //add the elapsed time and current word to the timestamp words mapping\n          setSyncedLyrics((syncedLyrics) =>\n            syncedLyrics.map((line, rowIndex) => {\n              return line.map((word, colIndex) => {\n                //if the currentWord set the time\n                if (rowIndex === row && colIndex === col) {\n                  word.time = playerRef.current.getCurrentTime();\n                }\n                return word;\n              });\n            })\n          );\n          //on last word of row, go to the start of the next row\n          if (syncedLyrics[row].length - 1 === col) {\n            return { row: row + 1, col: 0 };\n          }\n\n          //otherwise the next col\n          else {\n            return { row, col: col + 1 };\n          }\n        }\n      });\n    };\n    const detectKey = (event) => {\n      if (event.keyCode) {\n        if (!playing) {\n          setPlaying(true);\n          if (playerRef.current) {\n            console.log('ran')\n            playerRef.current.seekTo(startTime);\n          }\n        }\n        //if the video has started and a key was pressed, sync the current word\n        else if (!buffering) {\n          syncWord();\n        }\n      }\n    };\n    window.addEventListener('keydown', detectKey, false);\n    return () => window.removeEventListener('keydown', detectKey);\n  }, [buffering, playing, startTime]);\n\n  //saves the word and the time since the last word was synced {text, sleepAfter}. The initial timeStamp is a null word that simply denotes the length before the first lyric\n\n  //called whenever a word is synced\n\n  //create end time listener\n  useEffect(() => {\n    const interval = setInterval(() => {\n      if (playerRef.current) {\n        if (playerRef.current.getCurrentTime() > endTime) {\n          setEnded(true);\n        }\n      }\n    }, 1000);\n    return () => clearInterval(interval);\n  }, [playerRef, endTime]);\n\n  //used to tell the user what to do\n  const [instructions, setInstructions] = useState('Waiting for lyrics to be processed...');\n\n  //once the processed lyrics have been loaded, start listening to key presses\n  const { data } = useQuery(PROCESSED_LYRICS, {\n    variables: { id: geniusID },\n    onCompleted: () => {\n      ////remove __typename and set the synced lyrics to be the fetched ones\n      setSyncedLyrics(\n        data.processedLyrics.map((row) => {\n          return row.map((word) => {\n            delete word.__typename;\n            return word;\n          });\n        })\n      );\n      setInstructions('Press any key to start the video');\n    },\n  });\n\n  //when the startingTime has been set to a nonzero value by the video player the video has started playing\n  useEffect(() => {\n    if (!buffering) {\n      setInstructions('Whenever the highlighted word is said, press any key to sync it.');\n    }\n  }, [buffering]);\n\n  if (ended) {\n    return <LyricsSyncPreview syncedLyrics={syncedLyrics} startTime={startTime} endTime={endTime} />;\n  }\n  return (\n    <Container fluid style={{ paddingLeft: 0, paddingRight: 0 }}>\n      <CustomNavbar centerContent={<AnimatedP text={instructions} style={{ fontSize: 30, color: 'white', zIndex: 1000, textAlign: 'center' }} />} />\n      <Row className='justify-content-md-center'>\n        <ReactPlayer ref={playerRef} playing={playing} url={`https://www.youtube.com/watch?v=${youtubeID}`} onEnded={() => setEnded(true)} onBuffer={() => setBuffering(true)} onBufferEnd={() => setBuffering(false)} controls={false} />\n      </Row>\n      {data ? (\n        data.processedLyrics.slice(position.row).map((line, rowIndex) => {\n          return (\n            <Row className='justify-content-md-center' style={{ minWidth: '100%' }} key={rowIndex}>\n              {line.map((word, colIndex) => {\n                return rowIndex === 0 && colIndex === position.col  ? (\n                  <mark\n                    key={word.id}\n                    style={{\n                      backgroundColor: '#007bff',\n                      color: '#fff',\n                      marginBottom: 10,\n                      fontSize: '40px',\n                      marginLeft: '0.5em',\n                    }}\n                  >\n                    {word.text}\n                  </mark>\n                ) : (\n                  <p\n                    key={word.id}\n                    style={{\n                      marginBottom: 10,\n                      fontSize: '40px',\n                      marginLeft: '0.5em',\n                    }}\n                  >\n                    {word.text}\n                  </p>\n                );\n              })}\n            </Row>\n          );\n        })\n      ) : (\n        <Loading centered />\n      )}\n    </Container>\n  );\n}\n"],"sourceRoot":""}